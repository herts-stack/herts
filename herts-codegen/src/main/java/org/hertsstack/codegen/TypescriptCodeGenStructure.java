package org.hertsstack.codegen;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;

class TypescriptCodeGenStructure extends TypescriptBase {
    private final String serviceName;
    private final TypescriptFileName fileName;

    public TypescriptCodeGenStructure(String serviceName, TypeResolver typeResolver) {
        super(typeResolver);
        this.serviceName = serviceName;
        this.fileName = new TypescriptFileName(this.serviceName);
    }

    private void genNestedModel(StringBuilder codeStrBuilder, Class<?> targetClass) throws ClassNotFoundException {
        Field[] allFields = targetClass.getDeclaredFields();
        List<String> nestedModelPackages = new ArrayList<>();

        if (this.cacheGenCode.getGeneratedPackageNames().contains(targetClass.getSimpleName())) {
            return;
        }

        codeStrBuilder.append("\n\nexport class " + targetClass.getSimpleName() + " {");

        List<String> propertyDefinitions =  new ArrayList<>();
        List<String> propertyNames =  new ArrayList<>();

        for (Field field : allFields) {
            String propertyName = field.getName();
            String propertyType = field.getType().getName();

            if (propertyType.contains("$")) {
                Class<?> nestedClass = Class.forName(field.getType().getName());
                if (CodeGenUtil.isCustomModelClass(nestedClass)) {
                    nestedModelPackages.add(field.getType().getName());
                }

                String[] classSplit = propertyType.split("\\$");
                propertyType = classSplit[classSplit.length-1];

                propertyDefinitions.add(propertyName + ": " + propertyType);
                propertyNames.add(propertyName);
            } else {
                JavaType type = JavaType.findType(propertyType);
                TypescriptType typescriptType = this.typeResolver.convertType(type);

                propertyDefinitions.add(propertyName + ": " + typescriptType.getData());
                propertyNames.add(propertyName);
            }
        }

        // Constructor
        codeStrBuilder.append("\n\tconstructor(" + String.join(", ", propertyDefinitions) + ") {");
        for (String name : propertyNames) {
            codeStrBuilder.append("\n\t\tthis." + name + " = " + name);
        }
        codeStrBuilder.append("\n\t}");

        // Property
        for (String def : propertyDefinitions) {
            codeStrBuilder.append("\n\t" + def);
        }

        codeStrBuilder.append("\n}");

        this.cacheGenCode.addGeneratedPackageNames(targetClass.getSimpleName());

        // Recursive generate model
        for (String nestedModelPkg : nestedModelPackages) {
            Class<?> nestedClass = Class.forName(nestedModelPkg);
            genNestedModel(codeStrBuilder, nestedClass);
        }
    }

    private void senCustomPkgModelStr(Method[] methods, StringBuilder codeStr) {
        for (Method method : methods) {
            Class<?>[] parameterTypes = method.getParameterTypes();
            for (Class<?> paramTypeClass : parameterTypes) {
                if (CodeGenUtil.isCustomModelClass(paramTypeClass)) {
                    try {
                        genNestedModel(codeStr, paramTypeClass);
                    } catch (ClassNotFoundException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    private static final String REQUEST_HEADER_CLASS_NAME = "RequestHeaders";
    public void genStructureModel(Method[] methods, StringBuilder codeStr) {
        System.out.println("Typescript file name = " + this.fileName.getStructureFileName());
        System.out.println("Generating...");

        if (!this.cacheGenCode.getGeneratedPackageNames().contains(REQUEST_HEADER_CLASS_NAME)) {
            codeStr.append(CodeGenUtil.GEN_COMMENT);
            codeStr.append("\nexport type RequestHeaders = {");
            codeStr.append("\n\t[x: string]: string | number | boolean;");
            codeStr.append("\n}");
            this.cacheGenCode.addGeneratedPackageNames(REQUEST_HEADER_CLASS_NAME);
        }

        senCustomPkgModelStr(methods, codeStr);
    }

    public void genResponseModel(Method[] methods) {
        System.out.println("Typescript file name = " + this.fileName.getResponseFileName());
        System.out.println("Generating...");

        StringBuilder codeStr = new StringBuilder();
        codeStr.append("// Don't edit this file because this file is generated by herts codegen.");
        for (Method method : methods) {
            String capitalizeMethodName = CodeGenUtil.capitalizeFirstLetter(method.getName());

            // Response Class
            codeStr.append("\n\nexport class " + capitalizeMethodName + "Response {");
            codeStr.append("\n\tconstructor() {");
            codeStr.append("\n\t\tthis.payload = new " + capitalizeMethodName + "Payload();");
            codeStr.append("\n\t}");
            codeStr.append("\n\tpayload: " + capitalizeMethodName + "Payload;");
            codeStr.append("\n}");

            // Response Payload Class
            JavaType javaType = JavaType.findType(method.getReturnType().getName());
            String typescriptType = getTypescriptTypeStr(javaType, method.getReturnType());
            if (this.typeResolver.findType(typescriptType) == null) {
                codeStr.insert(CodeGenUtil.GEN_COMMENT.length(), "\n\nimport {" + typescriptType + "} from './" + this.fileName.getStructureTsFileName() + "'");
            }

            codeStr.append("\n\nexport class " + capitalizeMethodName + "Payload {");
            codeStr.append("\n\tconstructor() {");
            codeStr.append("\n\t\tthis.keyName = '';");
            codeStr.append("\n\t\tthis.value = null;");
            codeStr.append("\n\t\tthis.classInfo = '';");
            codeStr.append("\n\t}");
            codeStr.append("\n\tprivate keyName: string;");
            codeStr.append("\n\tvalue: " + typescriptType + ";");
            codeStr.append("\n\tprivate classInfo: string;");
            codeStr.append("\n}");
        }

        CodeGenUtil.writeFile(this.fileName.getResponseFileName(), codeStr.toString());
    }

    public void genRequestModel(Method[] methods) {
        System.out.println("Typescript file name = " + this.fileName.getRequestFileName());
        System.out.println("Generating...");

        StringBuilder codeStr = new StringBuilder();
        codeStr.append(CodeGenUtil.GEN_COMMENT);

        for (Method method : methods) {
            String capitalizeMethodName = CodeGenUtil.capitalizeFirstLetter(method.getName());
            String arrayPayloadType = "Array<" + capitalizeMethodName + "Payload>";

            // Request Class
            Class<?>[] parameterTypes = method.getParameterTypes();
            boolean hasParameter = parameterTypes.length > 0;

            codeStr.append("\n\nexport class " + capitalizeMethodName + "Request {");
            codeStr.append("\n\tprivate constructor(payloads: " + arrayPayloadType + ") {");
            codeStr.append("\n\t\tthis.payloads = payloads;");
            codeStr.append("\n\t}");
            codeStr.append("\n\tpayloads: " + arrayPayloadType + ";");
            codeStr.append("\n\tpublic static createRequest(");
            if (hasParameter) {
                for (int i = 0; i < parameterTypes.length; i++) {
                    Class<?> parameterTypeClass = parameterTypes[i];
                    JavaType javaType = JavaType.findType(parameterTypeClass.getName());
                    String typescriptType = getTypescriptTypeStr(javaType, parameterTypeClass);

                    if (this.typeResolver.findType(typescriptType) == null) {
                        codeStr.insert(CodeGenUtil.GEN_COMMENT.length(), "\n\nimport {" + typescriptType + "} from './" + this.fileName.getStructureTsFileName() + "'");
                    }

                    codeStr.append("arg" + i + ": " + typescriptType);
                    if (i != parameterTypes.length-1) {
                        codeStr.append(", ");
                    }
                }
            }
            codeStr.append(") {");
            codeStr.append("\n\t\tconst payloads = new " + arrayPayloadType + "();");
            if (hasParameter) {
                for (int i = 0; i < parameterTypes.length; i++) {
                    codeStr.append("\n\t\tconst payload" + i + " = new " + capitalizeMethodName + "Payload(");
                    codeStr.append("'arg" + i + "', ");
                    codeStr.append("arg" + i + ", ");
                    codeStr.append("'" + parameterTypes[i].getName() + "')");
                    codeStr.append("\n\t\tpayloads.push(payload" + i + ");");

                }
            }
            codeStr.append("\n\t\treturn new " + capitalizeMethodName + "Request(payloads);");
            codeStr.append("\n\t};");
            codeStr.append("\n}");

            // Request Payload Class
            codeStr.append("\n\nexport class " + capitalizeMethodName + "Payload {");
            codeStr.append("\n\tconstructor(keyName: string, value: any, classInfo: string) {");
            codeStr.append("\n\t\tthis.keyName = keyName;");
            codeStr.append("\n\t\tthis.value = value;");
            codeStr.append("\n\t\tthis.classInfo = classInfo;");
            codeStr.append("\n\t}");
            codeStr.append("\n\tprivate keyName: string;");
            codeStr.append("\n\tprivate value: any;");
            codeStr.append("\n\tprivate classInfo: string;");
            codeStr.append("\n}");
        }

        CodeGenUtil.writeFile(this.fileName.getRequestFileName(), codeStr.toString());
    }
}
